[toc]
# Socket高级知识
## 流Socket的部分读
部分读意思是`read(), write()`系统调用没有读够需要长度的字节数。以下情况发生时会发生部分读：  
1. 内核Buffer不够
2. `write()`被信号中断
3. `socket`以**O_NONBLOCK**模式打开
4. **异步错误**发生，比如对方的连接断开

部分IO并不是错误，只要读写了1个字节都算成功。

### 处理部分IO的函数
```c
#include "rdwrn.h"
ssize_t readn(int fd, void *buffer, size_t count);
Returns number of bytes read, 0 on EOF, or –1 on error
ssize_t writen(int fd, void *buffer, size_t count );
Returns number of bytes written, or –1 on erro
```
具体实现:在书的*Listing 61-1*

## shutdown()系统调用
```c
#include <sys/socket.h>
int shutdown(int sockfd , int how);
Returns 0 on success, or –1 on erro
```
关闭单向或者双向连接，具体取决于`how`参数。

| 参数值    | 行为                                                                                        |
|-----------|---------------------------------------------------------------------------------------------|
| SHUT_RD   | 关闭读（读返回**EOF**），可以写，连接对方会收到**SIGPIPE**信号，写的时候会产生**EPIPE**错误 |
| SHUT_WR   | 关闭写（写会收到**SIGPIPE**信号，产生**EPIPE**错误），可以读，应用于`ssh, rsh`程序          |
| SHUT_RDWR | 关闭读写                                                                                    |



`shutdown()`针对的是`file description`而非`file descriptor`，因此对文件描述符的`shutdown()`会影响所有指向此`file description`的`file descriptor`。而相对的`close()`针对的是`file descriptor`，然而由于`shutdown()`不能关闭文件描述符，所以总是得调用`close()`去关闭`file descriptor`。


## Socket特定IO系统调用 recv(), send()
```c
#include <sys/socket.h>
ssize_t recv(int sockfd , void *buffer, size_t length, int flags);
//Returns number of bytes received, 0 on EOF, or –1 on error
ssize_t send(int sockfd , const void *buffer, size_t length, int flags);
//Returns number of bytes sent, or –1 on error
```
它们和`read(), write()`的区别只在于第四个`flag`参数，对于读  

| 参数名       | 行为                                             |
|--------------|--------------------------------------------------|
| MSG_DONTWAIT | 非阻塞读写，如果没有数据，发生**EAGAIN**错误     |
| MSG_OOB      | 读超过界限的数据                                 |
| MSG_PEEK     | 读数据时不从buffer中移除                         |
| MSG_WAITALL  | 当可读数据小于需要的长度，阻塞知道读到足够的数据，可以代替`readn`函数 |
|              |                          |

对于写：  
| 参数名       | 行为                                                 |
|--------------|------------------------------------------------------|
| MSG_DONTWAIT | 非阻塞写，如果写不进去（buffer满了），**EAGAIN**错误 |
| MSG_NOSIGNAL | 写的时候屏蔽**SIGPIPE**信号（比如对方关闭连接）      |
| MSG_OOB      |                                                      |

## sendfile()系统调用
正常用循环`write()`写大文件的话比较低效，因为使用了两个系统调用，`read()`将数据从内核空间（`buffer cache`）拷贝到用户空间然后`write()`将数据从用户空间拷贝到内核空间（`socket buffer`）。  

```c
#include <sys/sendfile.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
//Returns number of bytes transferred, or –1 on error
```
`out_fd`是`socket fd`，而`in_fd`必须能用`mmap()`，所以这个函数只能上传文件而不能下载文件。  
### 使用TCP_CORK去优化TCP性能
正常的两次写会发出两个TCP报文段，而开启**TCP_CORK**会将写的数据放到一个单独的TCP段，直到：  
1. 报文段最大长度到了
2. **TPC_SOCK**关闭
3. `socket`关闭
4. 200毫秒的规定时间到了（目的是为了确保写的数据总是会发出去）

诚然，我们可以通过拼接buffer的方式实现**TCP_CORK**类似的功能，但是要想利用**sendfile()**这个函数的话，就需要使用**TCP_CROK**了。


## getsockname(), getpeername()
用于获取对应`sfd`的地址信息和流Socket对应的对方`socket`信息。

## TCP深探
### TCP段格式
