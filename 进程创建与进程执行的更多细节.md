# 进程创建与进程执行的更多细节
## 进程“会计”
当开启“进程会计”之后，内核会记录该进程到记录文件中，一般记录**进程退出状态、消耗的CPU时间**，该文件可以被系统分析软件分析如`sa`。

```c
#define _BSD_SOURCE
#include <unistd.h>
int acct(const char *acctfile);
//Returns 0 on success, or –1 on error
```
`acctfile`指定文件名，为**NULL**的话就关闭“进程记录”。主要内容就是`acct`结构体的内容了。
## clone()系统调用
`clone()`和`fork(), vfork()`很像，但是并不像其他几个那样在进程创建的时候做那些优化，而且`clone()`是在线程库里面实现的。
```c
#define _GNU_SOURCE
#include <sched.h>
int clone(int (*func) (void *), void *child_stack, int flags, void *func_arg, ...
/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );
//Returns process ID of child on success, or –1 on error
```
`func`指向新进程执行的函数地址，`child_stack`指向的是父进程为子进程分配的栈区地址（由于一般栈向下增长，所以指针指向地址的最后一位），`flags`控制子进程共享父进程的哪些资源，`func_args`指向传给子进程的参数。
### flags参数
首先要注意的是，要对“进程”和“线程”加以区分，引入“内核调度实体”来帮助我们理解这一点，“内核调度实体”是内核进行调度的对象，所以“进程”和“线程”都是“内核调度实体”，只是在共享属性（虚拟内存、打开的文件描述符、信号设置、进程ID...）上是多是少的问题。
### 共享文件描述符表 CLONE_FILES
如果**CLONE_FILES**标志设置，那么父亲孩子会共享一张打开的文件描述符表，所以对文件描述符的操作对双方是可见的，对于`fork(), vfork()`不会设置这个标志，而**POSIX**标准的线程会设置这个标志。
### 共享文件系统相关信息 CLONE_FS
如果设置了这个标志，那么父亲、孩子会共享文件系统相关信息（`umask, root dir, work dir`），这样`umask(), chdir(), chroot()`会同时影响两个“内核调度实体”，对于`fork(), vfork()`不会设置这个标志，而**POSIX**标准的线程会设置这个标志。
### 共享信号处理器 CLONE_SIGHAND
如果设置了这个标志，那么父亲、孩子会共享信号处理函数表，对于信号量的函数注册会同时影响两个“内核调度实体”，对于`fork(), vfork()`不会设置这个标志，而**POSIX**标准的线程会设置这个标志。对于信号屏蔽量和挂起信号在父亲和孩子是独立的，并且如果**CLONE_SIGHAND**设置，那么**CLONE_VM**必须被设置。
### 共享父亲的虚拟内存 CLONE_VM
如果设置了此标志，那么“内核调度实体”对内存的修改会对双方可见，`fork()`不设置此标志，`vfork()`和**POSIX**标准线程会设置。
### 线程组标志 CLONE_TREAD
如果设置此标志，那么会将父亲、孩子放置到同一个线程组，否则孩子会在一个新的线程组，一个线程组就是多个或一个共享统一个进程ID的“内核调度实体”组成的组，但是每个“内核调度实体”都拥有一个系统唯一的“线程ID”，这也是`clone()`系统调用返回的值，线程组的组长进程号与线程号相同，设置此标志`clone()`出的“内核调度实体”终止后不会发出**SIGCHLD**信号，所以`wait()`无法使用而只能使用`pthread_join()`。  
如果一个线程使用了`exec()`执行新程序，那么它会变成线程组组长并且所在的线程组其他线程都会被终止，改线程终止信号将会变为**SIGCHLD**，而当一个线程使用了`fork(), vfork()`后该线程组的所有成员都能用`wait()`获得子进程的退出状态。
## 进程创建的速度


## exec(), fork()对于进程属性的影响

