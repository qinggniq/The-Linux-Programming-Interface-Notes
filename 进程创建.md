# 进程创建

开局一张图，图在24章第一节。

## 创建一个新的进程
```c
int fork();
//child return 0, parent return child pid.
```

### 文件共享机制

子进程和父进程共享系统文件描述符`file description`，然后父进程级别文件描述符`file descriptor`和子进程的表是一样的，所以父进程通过文件描述符读写文件造成的变化（如偏移量，标志）子进程可以看到。
### fork()的内存机制

由于`fork()`后面一般跟着`exec()`，所以如果简单地将父进程的**TEXT, DATA, STACK, HEAP**段都复制过去的话，势必造成性能上的极大浪费，所以`fork()`使用两个机制来进行内存处理：  

1. **TEXT段**只读，因为TEXT为程序段，通常情况下没有程序会动态修改这个段，所以设置为只读，既然只读了，那么就可以使用共享机制直接将它共享给子进程就好了。
2. **copy on write（写时复制）**，顾名思义，就是只有子进程对进程空间进行写操作时，才会真正进行复制操作，并且复制也不是全部复制，只复制写的**页**。

### 小tips
由于系统会自动回收进程的空间，这个空间包括**HEAP**段在内的空间，所以如果你有个程序发生了内存泄漏，或者`free()`的逻辑太复杂，可以使用下面的小技巧去优雅地解决它：
```c
int status;

if (fork() == 0) {
    //child
    exit(func());
} else {
    //father
    wait(&status);
}

```
嗯，如果你的`func()`程序的返回值并不是`int`，又想获得它的返回的话，那么写一个包装函数，让它执行你的程序并且返回`int`，返回值的话用`IPC（进程通信机制）`给父进程就行了。

## vfork()

这个函数出现的动机就是很多`fork()`出来的子进程后面都跟着`exec()`，所以就懒得复制父进程空间了，`vfork()`之后标准是要求用户立马就执行`exec()`的，它机制是这样的：  
1. 甚至都不复制父进程的虚拟页表，它直接共享父进程内存给子进程知道调用`exec()`。
2. 在子进程执行`exec()`前，父进程挂起。

**1**会导致子进程对空间的修改父进程可见（这个与`fork()`父子进程空间隔离不一样），嗯不过`vfork()`复制了**文件描述符表**。综上，能用`fork()`不要用`vfork()`，因为 *vfork()酱真的很严格！*。 


## fork()后的race condition
对于`fork()`，我们不能保证`fork()`后是子进程先行还是父进程先行，一般Linux都是父进程先行，不过可以配置系统文件`/proc/sys/kernel/sched_child_runs_first`让子进程先行。从效率上讲：  
1. 父进程先行 => 程序的局部性，父进程的状态、内存空间已经在物理内存里面了，然后TLB又会“预读”到高速缓存，所以比较快。
2. 子进程先行 => 子进程一般直接执行`exec()`，所以不用复制进程空间，而父进程先行的话一般会修改进程空间，这时候会触发**页复制**。

## 通过信号解决race condition
嗯，等我看了*信号*再说。

