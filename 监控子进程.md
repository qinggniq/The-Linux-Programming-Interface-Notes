# 监控子程序
许多应用设计中父进程需要知道子进程是不是被终止了，接下来介绍2种监控子进程的技术：`wait()`系统调用和**SIGCHLD**信号。
## 等待子进程
### wait()系统调用
```
#include <sys/wait.h>
pid_t wait(int *status);
//Returns process ID of terminated child, or –1 on error
```
1. 阻塞直至有一个子进程终止。
2. `status`保存子进程的退出状态。
3. 内核将*CPU时间和资源使用数据*加到父进程中。
4. 返回终止子进程的`pid`。

如果没有子进程了，则返回-1，然后设置`errno`为**ECHILD**。

### waitpid()系统调用




## 孤儿和僵尸
孤儿：父进程结束、子进程没结束
僵尸：子进程结束，父进程还没运行到`wait()`调用或者结束，子进程的资源被释放，内核进程表里记录着子进程的进程ID，终止状态，资源使用情况。不能被信号杀掉。

如果子进程结束了父进程没结束并且不调用`wait()`，那么`init`进程收养然后`wait()`。如果系统里面有大量的僵尸进程，由于僵尸进程不能被信号杀死`kill -9 pid`，则解决办法就只能`kill`掉父进程，然后让`init`进程去处理。  
在父进程常驻的服务中，父进程应该使用`wait()`去处理僵尸进程（同步或者异步）。

## SIGCHLD信号
正常的父进程处理子进程的退出有两种方式：
1. 调用`wait(), waitpid()`阻塞地等待子进程退出
2. 调用`waitpid()`非阻塞地等待子进程退出，使用循环一直判断。
然后有一种优雅的处理方式

### 为**SIGCHLD**信号建立处理函数
由于`sighandler`在调用的时候会阻塞一段时间，所以可能多个子进程退出而只调用一次处理函数。处理方法就是在方法中加个循环。


#### 在信号处理函数建立前子进程退出
各种标准对此情况的行为不同，最好在`fork()`前就建立`handler`。

#### 信号处理函数可能会改变全局的errno变量
在信号处理函数里面先保存之前的值。

#### 将SIGCHLD忽略

就是将子进程的退出信号忽略，然后`init`进程处理子进程，也不会产生僵尸进程。
```c
signal(SIGCHLD, SIG_IGN);
```
因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。(Linux Only)

对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN。
